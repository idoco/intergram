{"version":3,"sources":["webpack:///widget.js","webpack:///webpack/bootstrap 0355b12dce7bac8e52bc?f643","webpack:///./~/preact/dist/preact.js?bec8","webpack:///./src/widget/App.js","webpack:///./src/widget/ChatFrame.js","webpack:///./src/widget/widgetIndex.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","0","1","global","factory","this","VNode","nodeName","attributes","children","key","extend","obj","props","i","clone","delve","split","length","toArray","offset","slice","isFunction","isString","empty","x","falsey","value","hashToClassName","str","prop","h","firstChild","arr","lastSimple","len","arguments","type","String","_p","join","SHARED_TEMP_ARRAY","j","child","simple","push","class","className","options","vnode","cloneElement","createLinkedState","component","eventPath","path","p0","e","_component$setState","v","t","currentTarget","s","state","_component","match","checked","setState","enqueueRender","items","debounceRendering","defer","rerender","currentItems","itemsOffline","pop","_dirty","renderComponent","isFunctionalComponent","prototype","render","buildFunctionalComponent","context","getNodeProps","EMPTY","ensureNodeData","node","data","ATTR_KEY","getNodeType","Text","Element","removeNode","parentNode","removeChild","setAccessor","name","old","isSvg","style","cssText","NON_DIMENSION_PROPS","innerHTML","__html","l","_listeners","toLowerCase","substring","addEventListener","eventProxy","removeEventListener","setProperty","removeAttribute","ns","removeAttributeNS","setAttributeNS","setAttribute","event","getRawNodeAttributes","attrs","isSameNodeType","isNamedNode","_componentConstructor","normalizedNodeName","defaultProps","collectNode","cleanNode","list","nodes","createNode","document","createElementNS","createElement","flushMounts","mounts","componentDidMount","diff","dom","mountAll","parent","rootComponent","nextSibling","diffLevel","ret","idiff","insertBefore","originalAttributes","nodeType","createComment","nodeValue","createTextNode","svgMode","out","buildComponentFromVNode","isSvgMode","appendChild","recollectNodeTree","childNodes","innerDiffNode","diffAttributes","ref","vchildren","vchild","originalChildren","keyed","keyedLen","min","childrenLen","vlen","_child","__key","removeOrphanedChildren","unmountOnly","unmountComponent","_name","_name2","collectComponent","constructor","components","createComponent","Ctor","inst","nextBase","splice","triggerComponentRender","setComponentProps","opts","b","base","_disableRendering","__ref","componentWillMount","componentWillReceiveProps","prevContext","prevProps","syncComponentUpdates","skip","rendered","previousProps","previousState","prevState","previousContext","isUpdate","initialBase","baseParent","initialComponent","initialChildComponent","shouldComponentUpdate","componentWillUpdate","getChildContext","toUnmount","childComponent","childProps","_parentComponent","cbase","componentRef","unshift","componentDidUpdate","fn","cb","_renderCallbacks","oldDom","isDirectOwner","isOwner","remove","componentWillUnmount","inner","componentDidUnmount","Component","_linkedStates","getInitialState","merge","lcCache","resolved","Promise","resolve","f","then","setTimeout","Symbol","for","boxFlex","boxFlexGroup","columnCount","fillOpacity","flex","flexGrow","flexPositive","flexShrink","flexNegative","fontWeight","lineClamp","lineHeight","opacity","order","orphans","strokeOpacity","widows","zIndex","zoom","linkState","cacheKey","callback","forceUpdate","31","_interopRequireDefault","__esModule","default","_objectDestructuringEmpty","TypeError","_classCallCheck","instance","Constructor","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","Object","create","enumerable","writable","configurable","setPrototypeOf","__proto__","defineProperty","_createClass","defineProperties","target","descriptor","protoProps","staticProps","_preact","_ChatFrame","_ChatFrame2","wrapperStyle","position","bottom","right","borderRadius","border","width","titleStyle","height","fontSize","paddingLeft","fontFamily","background","color","cursor","App","_Component","_ref","_temp","_this","_ret","_len","args","Array","_key","getPrototypeOf","apply","concat","pristine","isChatOpen","onClick","window","intergramId","console","error","_ref2","_ref3","display","32","ChatFrame","src","frameborder","33","injectChat","root","getElementsByTagName","_App2","_App","attachEvent"],"mappings":"CAAS,SAAUA,GCInB,QAAAC,GAAAC,GAGA,GAAAC,EAAAD,GACA,MAAAC,GAAAD,GAAAE,OAGA,IAAAC,GAAAF,EAAAD,IACAE,WACAE,GAAAJ,EACAK,UAUA,OANAP,GAAAE,GAAAM,KAAAH,EAAAD,QAAAC,IAAAD,QAAAH,GAGAI,EAAAE,UAGAF,EAAAD,QAvBA,GAAAD,KAqCA,OATAF,GAAAQ,EAAAT,EAGAC,EAAAS,EAAAP,EAGAF,EAAAU,EAAA,WAGAV,EAAA,KDMMW,EACA,SAASP,EAAQD,EAASH,GAE/BI,EAAOD,QAAUH,EAAoB,KAKhCY,EACA,SAASR,EAAQD,EAASH,IErDhC,SAAAa,EAAAC,GACAA,EAAAX,IACCY,KAAA,SAAAZ,GACD,QAAAa,GAAAC,EAAAC,EAAAC,GACAJ,KAAAE,WACAF,KAAAG,aACAH,KAAAI,WACAJ,KAAAK,IAAAF,KAAAE,IAEA,QAAAC,GAAAC,EAAAC,GACA,GAAAA,EAAA,OAAAC,KAAAD,GAAA,SAAAA,EAAAC,KAAAF,EAAAE,GAAAD,EAAAC,GACA,OAAAF,GAEA,QAAAG,GAAAH,GACA,MAAAD,MAAwBC,GAExB,QAAAI,GAAAJ,EAAAF,GACA,OAAAV,GAAAU,EAAAO,MAAA,KAAAH,EAAA,EAA2CA,EAAAd,EAAAkB,QAAAN,EAAqBE,IAAAF,IAAAZ,EAAAc,GAChE,OAAAF,GAEA,QAAAO,GAAAP,EAAAQ,GACA,SAAAC,MAAAxB,KAAAe,EAAAQ,GAEA,QAAAE,GAAAV,GACA,wBAAAA,GAEA,QAAAW,GAAAX,GACA,sBAAAA,GAEA,QAAAY,GAAAC,GACA,gBAAAA,GAAA,OAAAA,EAEA,QAAAC,GAAAC,GACA,MAAAA,SAAAH,EAAAG,GAEA,QAAAC,GAAA7B,GACA,GAAA8B,GAAA,EACA,QAAAC,KAAA/B,KAAA+B,KACAD,OAAA,KACAA,GAAAC,EAEA,OAAAD,GAEA,QAAAE,GAAAxB,EAAAC,EAAAwB,GACA,GAAAvB,GAAAwB,EAAAC,EAAAC,EAAAC,UAAAlB,MACA,IAAAiB,EAAA,GACA,GAAAE,SAAAL,EACA,QAAAG,GAAA,WAAAE,GAAA,aAAAA,EACAX,EAAAM,KAAAvB,GAAA6B,OAAAN,SACa,CACbvB,IACA,QAAAK,GAAA,EAA+BA,EAAAqB,EAASrB,IAAA,CACxC,GAAAyB,GAAAH,UAAAtB,EACA,KAAAY,EAAAa,GAAA,CACAA,EAAAC,KAAAP,EAAAM,GAA8CN,EAAAQ,GAAA,GAAAF,CAC9C,QAAAG,GAAA,EAAuCA,EAAAT,EAAAf,OAAgBwB,IAAA,CACvD,GAAAC,GAAAV,EAAAS,GAAAE,IAAAlB,EAAAiB,IAAArB,EAAAqB,gBAAArC,GACAsC,KAAArB,EAAAoB,OAAAL,OAAAK,IACAC,GAAAV,EAAAzB,IAAAS,OAAA,IAAAyB,EAA6FjB,EAAAiB,KAC7FlC,EAAAoC,KAAAF,GACAT,EAAAU,WAMS,IAAApC,KAAAC,SAAA,MAAAsB,GAAAxB,EAAAC,IAAAC,SACTD,KACAA,EAAAC,gBAAAD,GAAAC,SACAa,EAAAf,KACA,aAAAC,KACAA,EAAAsC,MAAAtC,EAAAuC,gBACAvC,GAAAuC,WAEAb,EAAA1B,EAAAsC,MACAZ,IAAAX,EAAAW,KAAA1B,EAAAsC,MAAAlB,EAAAM,KAGA,IAAAlC,GAAA,GAAAM,GAAAC,EAAAC,GAAA,OAAAC,EAEA,OADAuC,GAAAC,OAAAD,EAAAC,MAAAjD,GACAA,EAEA,QAAAkD,GAAAD,EAAApC,GACA,MAAAkB,GAAAkB,EAAA1C,SAAAI,EAAAI,EAAAkC,EAAAzC,YAAAK,GAAAuB,UAAAlB,OAAA,EAAAC,EAAAiB,UAAA,GAAAa,EAAAxC,UAEA,QAAA0C,GAAAC,EAAA1C,EAAA2C,GACA,GAAAC,GAAA5C,EAAAO,MAAA,KAAAsC,EAAAD,EAAA,EACA,iBAAAE,GACA,GAAAC,GACAC,EAAA5C,EAAA6C,EAAAH,KAAAI,eAAAvD,KAAAwD,EAAAT,EAAAU,MAAAlD,EAAAiD,CAMA,IALAtC,EAAA8B,IACAK,EAAA1C,EAAAwC,EAAAH,GACA7B,EAAAkC,KAAAC,IAAAI,cAAAL,EAAA1C,EAAA2C,EAAAN,KACaK,EAAAC,EAAApD,UAAAoD,EAAApD,SAAAoD,EAAAtB,MAAA2B,MAAA,sBAAAL,EAAAM,QAAAN,EAAAhC,MAAA6B,EACblC,EAAAoC,SAAA7D,KAAA8D,IACAL,EAAApC,OAAA,GACA,IAAAJ,EAAA,EAA2BA,EAAAwC,EAAApC,OAAA,EAAqBJ,IAAAF,IAAA0C,EAAAxC,MAAAF,EAAA0C,EAAAxC,OAChDF,GAAA0C,EAAAxC,IAAA4C,EACAA,EAAAG,EAAAN,GAEAH,EAAAc,UAAAT,KAAwDA,EAAAF,GAAAG,EAAAD,KAGxD,QAAAU,GAAAf,GACA,IAAAgB,GAAAvB,KAAAO,KAAAJ,EAAAqB,mBAAAC,GAAAC,GAEA,QAAAA,KACA,GAAAH,GAAAlD,OAAA,CACA,GAAAlB,GAAAwE,EAAAJ,EAGA,KAFAA,GAAAK,GACAA,GAAAD,EACAxE,EAAAwE,EAAAE,OAAA1E,EAAA2E,QAAAC,EAAA5E,IAGA,QAAA6E,GAAA5B,GACA,GAAA1C,GAAA0C,KAAA1C,QACA,OAAAA,IAAAe,EAAAf,QAAAuE,WAAAvE,EAAAuE,UAAAC,QAEA,QAAAC,GAAA/B,EAAAgC,GACA,MAAAhC,GAAA1C,SAAA2E,EAAAjC,GAAAgC,GAAAE,GAEA,QAAAC,GAAAC,EAAAC,GACA,MAAAD,GAAAE,MAAAF,EAAAE,IAAAD,OAEA,QAAAE,GAAAH,GACA,MAAAA,aAAAI,MAAA,EACAJ,YAAAK,SAAA,EAA8C,EAE9C,QAAAC,GAAAN,GACA,GAAArF,GAAAqF,EAAAO,UACA5F,MAAA6F,YAAAR,GAEA,QAAAS,GAAAT,EAAAU,EAAApE,EAAAqE,EAAAC,GAEA,GADAb,EAAAC,GAAAU,GAAApE,EACA,QAAAoE,GAAA,aAAAA,GAAA,cAAAA,EAAA,aAAAA,GAAAE,EAAwI,aAAAF,GAExI,KADApE,GAAAJ,EAAAI,IAAAJ,EAAAyE,MAAAX,EAAAa,MAAAC,QAAAxE,GAAA,IACAA,GAAA,gBAAAA,GAAA,CACA,IAAAJ,EAAAyE,GAAA,OAAAlF,KAAAkF,GAAAlF,IAAAa,KAAA0D,EAAAa,MAAApF,GAAA,GACA,QAAAA,KAAAa,GAAA0D,EAAAa,MAAApF,GAAA,gBAAAa,GAAAb,IAAAsF,GAAAtF,GAAAa,EAAAb,GAAAa,EAAAb,GAAA,UAES,gCAAAiF,EACTpE,IAAA0D,EAAAgB,UAAA1E,EAAA2E,YACS,IAAAP,EAAA/B,MAAA,SACT,GAAAuC,GAAAlB,EAAAmB,aAAAnB,EAAAmB,cACAT,GAAAU,EAAAV,EAAAW,UAAA,IACA/E,EACA4E,EAAAR,IAAAV,EAAAsB,iBAAAZ,EAAAa,GACaL,EAAAR,IAAAV,EAAAwB,oBAAAd,EAAAa,GACbL,EAAAR,GAAApE,MACS,aAAAoE,IAAAE,GAAAF,IAAAV,GACTyB,EAAAzB,EAAAU,EAAAvE,EAAAG,GAAA,GAAAA,GACAD,EAAAC,IAAA0D,EAAA0B,gBAAAhB,OACS,CACT,GAAAiB,GAAAf,GAAAF,EAAA/B,MAAA,gBACAtC,GAAAC,GAAAqF,EAAA3B,EAAA4B,kBAAA,+BAAAR,EAAAO,EAAA,KAAkH3B,EAAA0B,gBAAAhB,GAAiC,gBAAApE,IAAAL,EAAAK,KAAAqF,EAAA3B,EAAA6B,eAAA,+BAAAT,EAAAO,EAAA,IAAArF,GAAiJ0D,EAAA8B,aAAApB,EAAApE,QApBpS0D,GAAAtC,UAAApB,GAAA,GAuBA,QAAAmF,GAAAzB,EAAAU,EAAApE,GACA,IACA0D,EAAAU,GAAApE,EACS,MAAA6B,KAET,QAAAoD,GAAApD,GACA,MAAAnD,MAAAmG,WAAAhD,EAAAnB,MAAAW,EAAAoE,OAAApE,EAAAoE,MAAA5D,OAEA,QAAA6D,GAAAhC,GAEA,OADAiC,MACAxG,EAAAuE,EAAA7E,WAAAU,OAA4CJ,KAAKwG,EAAAjC,EAAA7E,WAAAM,GAAAiF,MAAAV,EAAA7E,WAAAM,GAAAa,KACjD,OAAA2F,GAEA,QAAAC,GAAAlC,EAAApC,GACA,MAAA1B,GAAA0B,GAAA,IAAAuC,EAAAH,GACA9D,EAAA0B,EAAA1C,UAAAiH,EAAAnC,EAAApC,EAAA1C,UACAe,EAAA2B,EAAA1C,UAAA8E,EAAAoC,wBAAAxE,EAAA1C,UAAAsE,EAAA5B,GAAA,OAEA,QAAAuE,GAAAnC,EAAA9E,GACA,MAAA8E,GAAAqC,qBAAAnH,GAAAkG,EAAApB,EAAA9E,YAAAkG,EAAAlG,GAEA,QAAA2E,GAAAjC,GACA,GAAA0E,GAAA1E,EAAA1C,SAAAoH,aAAA9G,EAAAE,EAAA4G,GAAA1E,EAAAzC,WAGA,OAFAmH,IAAAhH,EAAAE,EAAAoC,EAAAzC,YACAyC,EAAAxC,WAAAI,EAAAJ,SAAAwC,EAAAxC,UACAI,EAEA,QAAA+G,GAAAvC,GACAwC,EAAAxC,EACA,IAAAU,GAAAU,EAAApB,EAAA9E,UAAAuH,EAAAC,GAAAhC,EACA+B,KAAAjF,KAAAwC,GAAkC0C,GAAAhC,IAAAV,GAElC,QAAA2C,GAAAzH,EAAA0F,GACA,GAAAF,GAAAU,EAAAlG,GAAA8E,EAAA0C,GAAAhC,IAAAgC,GAAAhC,GAAArB,QAAAuB,EAAAgC,SAAAC,gBAAA,6BAAA3H,GAAA0H,SAAAE,cAAA5H,GAGA,OAFA6E,GAAAC,GACAA,EAAAqC,mBAAA3B,EACAV,EAEA,QAAAwC,GAAAxC,GACAM,EAAAN,GACA,IAAAG,EAAAH,KACAD,EAAAC,EAAAgC,EAAAhC,IACAA,EAAAtB,WAAAsB,EAAAoC,sBAAA,MAGA,QAAAW,KAEA,IADA,GAAArI,GACAA,EAAAsI,GAAA3D,OAAA3E,EAAAuI,mBAAAvI,EAAAuI,oBAEA,QAAAC,GAAAC,EAAAvF,EAAAgC,EAAAwD,EAAAC,EAAAC,EAAAC,GACAC,IACA,IAAAC,GAAAC,EAAAP,EAAAvF,EAAAgC,EAAAwD,EAAAE,EAGA,OAFAD,IAAAI,EAAAlD,aAAA8C,KAAAM,aAAAF,EAAAF,GAAA,QACAC,IAAAT,IACAU,EAEA,QAAAC,GAAAP,EAAAvF,EAAAgC,EAAAwD,EAAAE,GAEA,IADA,GAAAM,GAAAhG,KAAAzC,WACAqE,EAAA5B,MAAA+B,EAAA/B,EAAAgC,EACA,IAAAzD,EAAAyB,KACAA,EAAA,GACA0F,GAAA,CACA,GAAAH,EAAA,CACA,OAAAA,EAAAU,SAAA,MAAAV,EACAZ,GAAAY,GAEA,MAAAP,UAAAkB,cAAAlG,GAGA,GAAA1B,EAAA0B,GAAA,CACA,GAAAuF,EAAA,CACA,OAAAhD,EAAAgD,MAAA5C,WAEA,MADA4C,GAAAY,UAAAnG,EACAuF,CAEAZ,GAAAY,GAEA,MAAAP,UAAAoB,eAAApG,GAEA,GAAAqG,GAAAC,EAAAf,EAAAjI,EAAA0C,EAAA1C,QACA,IAAAe,EAAAf,GAAA,MAAAiJ,GAAAhB,EAAAvF,EAAAgC,EAAAwD,EAIA,IAHAlH,EAAAhB,OAAA+B,OAAA/B,IACA+I,EAAA,QAAA7C,EAAAlG,GACA+I,IAAAG,OACAjB,GAAwD,IAAAhB,EAAAgB,EAAAjI,GAAA,CAExD,IADAgJ,EAAAvB,EAAAzH,EAAAkJ,IACAjB,EAAAxG,YAAAuH,EAAAG,YAAAlB,EAAAxG,WACA2H,GAAAnB,QAHAe,GAAAvB,EAAAzH,EAAAkJ,GASA,OAJAxG,GAAAxC,UAAA,IAAAwC,EAAAxC,SAAAS,QAAA,gBAAA+B,GAAAxC,SAAA,QAAA8I,EAAAK,WAAA1I,QAAAqI,EAAAvH,qBAAAyD,MAAA8D,EAAAvH,WAAAoH,UAAAnG,EAAAxC,SAAA,IAAiNwC,EAAAxC,UAAA8I,EAAAvH,aAAA6H,EAAAN,EAAAtG,EAAAxC,SAAAwE,EAAAwD,GACjNqB,EAAAP,EAAAtG,EAAAzC,YACAyI,KAAAc,MAAAR,EAAAhE,IAAAwE,IAAAd,EAAAc,KAAAR,GACAD,IAAAG,OACAF,EAEA,QAAAM,GAAArB,EAAAwB,EAAA/E,EAAAwD,GACA,GAAA/F,GAAA3C,EAAAkK,EAAAtH,EAAAuH,EAAA1B,EAAAoB,WAAAnJ,KAAA0J,KAA6FC,EAAA,EAAAC,EAAA,EAAAlI,EAAA+H,EAAAhJ,OAAAoJ,EAAA,EAAAC,EAAAP,KAAA9I,MAC7F,IAAAiB,EAAA,OAAArB,GAAA,EAAgCA,EAAAqB,EAASrB,IAAA,CACzC,GAAA0J,GAAAN,EAAApJ,GAAAJ,EAAA6J,GAAAxK,EAAAyK,EAAAzG,YAAAhE,EAAA0K,OAAA1K,EAAAyK,EAAAjF,KAAAxF,EAAAW,IAAA,SACAA,IAAA,IAAAA,GACA0J,IACAD,EAAAzJ,GAAA8J,GACa/J,EAAA6J,KAAAE,EAEb,GAAAD,EAAA,OAAAzJ,GAAA,EAAiCA,EAAAyJ,EAAUzJ,IAAA,CAG3C,GAFAmJ,EAAAD,EAAAlJ,GACA6B,EAAA,KACAyH,GAAAH,EAAAzJ,WAAA,CACA,GAAAE,GAAAuJ,EAAAvJ,KACAc,EAAAd,QAAAyJ,KACAxH,EAAAwH,EAAAzJ,GACAyJ,EAAAzJ,GAAA,OACA0J,KAGA,IAAAzH,GAAA0H,EAAAC,EAAA,IAAA5H,EAAA2H,EAA0D3H,EAAA4H,EAAiB5H,IAE3E,GADA3C,EAAAU,EAAAiC,GACA3C,GAAAwH,EAAAxH,EAAAkK,GAAA,CACAtH,EAAA5C,EACAU,EAAAiC,GAAA,OACAA,IAAA4H,EAAA,GAAAA,IACA5H,IAAA2H,MACA,OAGA1H,EAAAoG,EAAApG,EAAAsH,EAAAhF,EAAAwD,GACA9F,IAAAuH,EAAApJ,IAAA0H,EAAAQ,aAAArG,EAAAuH,EAAApJ,IAAA,MAEA,GAAAsJ,EAAA,OAAAtJ,KAAAqJ,KAAArJ,KAAAL,EAAA4J,EAAAC,KAAAH,EAAArJ,GACAuJ,GAAAC,GAAAI,EAAAjK,GAEA,QAAAiK,GAAAjK,EAAAkK,GACA,OAAA7J,GAAAL,EAAAS,OAAqCJ,KAAK,CAC1C,GAAA6B,GAAAlC,EAAAK,EACA6B,IAAAgH,EAAAhH,EAAAgI,IAGA,QAAAhB,GAAAtE,EAAAsF,GACA,GAAAvH,GAAAiC,EAAAtB,UACAX,GAAAwH,EAAAxH,GAAAuH,IACAtF,EAAAE,KAAAF,EAAAE,IAAAwE,KAAA1E,EAAAE,IAAAwE,IAAA,MACAY,GAAA/C,EAAAvC,GACAA,EAAAuE,YAAAvE,EAAAuE,WAAA1I,QAAAwJ,EAAArF,EAAAuE,WAAAe,IAGA,QAAAb,GAAAtB,EAAAlB,GACA,GAAAtB,GAAAwC,EAAAjD,KAAA8B,EAAAmB,EACA,QAAAqC,KAAA7E,GAAAsB,GAAAuD,IAAAvD,IAAAxB,EAAA0C,EAAAqC,EAAA,KAAA7E,EAAA6E,GAAApB,GACA,IAAAnC,EAAA,OAAAwD,KAAAxD,GAAAwD,IAAA9E,IAAAsB,EAAAwD,IAAA9E,EAAA8E,KAAA,UAAAA,GAAA,YAAAA,GAAAxD,EAAAwD,IAAAtC,EAAAsC,KAAAhF,EAAA0C,EAAAsC,EAAAxD,EAAAwD,GAAA9E,EAAA8E,GAAArB,IAEA,QAAAsB,GAAA3H,GACA,GAAA2C,GAAA3C,EAAA4H,YAAAjF,KAAA+B,EAAAmD,GAAAlF,EACA+B,KAAAjF,KAAAO,GAAuC6H,GAAAlF,IAAA3C,GAEvC,QAAA8H,GAAAC,EAAAtK,EAAAoE,GACA,GAAAmG,GAAA,GAAAD,GAAAtK,EAAAoE,GAAA6C,EAAAmD,GAAAE,EAAApF,KAGA,IAFAqF,EAAAvK,QACAuK,EAAAnG,UACA6C,EAAA,OAAAhH,GAAAgH,EAAA5G,OAA2CJ,KAAK,GAAAgH,EAAAhH,GAAAkK,cAAAG,EAAA,CAChDC,EAAAC,SAAAvD,EAAAhH,GAAAuK,SACAvD,EAAAwD,OAAAxK,EAAA,EACA,OAEA,MAAAsK,GAEA,QAAAG,GAAAnI,GACAA,EAAAuB,SACAvB,EAAAuB,UACAR,EAAAf,IAGA,QAAAoI,GAAApI,EAAAvC,EAAA4K,EAAAxG,EAAAwD,GACA,GAAAiD,GAAAtI,EAAAuI,IACAvI,GAAAwI,oBACAxI,EAAAwI,sBACAxI,EAAAyI,MAAAhL,EAAAkJ,YAAAlJ,GAAAkJ,KACA3G,EAAAqH,MAAA5J,EAAAH,YAAAG,GAAAH,IACAc,EAAAkK,IAAAjD,EACArF,EAAA0I,oBAAA1I,EAAA0I,qBACa1I,EAAA2I,2BAAA3I,EAAA2I,0BAAAlL,EAAAoE,GACbA,OAAA7B,EAAA6B,UACA7B,EAAA4I,cAAA5I,EAAA4I,YAAA5I,EAAA6B,SACA7B,EAAA6B,WAEA7B,EAAA6I,YAAA7I,EAAA6I,UAAA7I,EAAAvC,OACAuC,EAAAvC,QACAuC,EAAAwI,qBACA,IAAAH,IAAA,IAAAA,GAAAzI,EAAAkJ,2BAAAR,EAAiIH,EAAAnI,GAAjIwB,EAAAxB,EAAA,EAAAqF,IACArF,EAAAyI,OAAAzI,EAAAyI,MAAAzI,IAGA,QAAAwB,GAAAxB,EAAAqI,EAAAhD,GACA,IAAArF,EAAAwI,kBAAA,CACA,GAAAO,GAAAC,EAAAvL,EAAAuC,EAAAvC,MAAAiD,EAAAV,EAAAU,MAAAmB,EAAA7B,EAAA6B,QAAAoH,EAAAjJ,EAAA6I,WAAApL,EAAAyL,EAAAlJ,EAAAmJ,WAAAzI,EAAA0I,EAAApJ,EAAA4I,aAAA/G,EAAAwH,EAAArJ,EAAAuI,KAAAe,EAAAD,GAAArJ,EAAAiI,SAAAsB,EAAAD,KAAA9G,WAAAgH,EAAAF,KAAA3I,WAAA8I,EAAAzJ,EAAAW,UAYA,IAXA0I,IACArJ,EAAAvC,MAAAwL,EACAjJ,EAAAU,MAAAwI,EACAlJ,EAAA6B,QAAAuH,EACA,IAAAf,GAAArI,EAAA0J,uBAAA1J,EAAA0J,sBAAAjM,EAAAiD,EAAAmB,QAAAkH,KAA8I/I,EAAA2J,qBAAA3J,EAAA2J,oBAAAlM,EAAAiD,EAAAmB,GAC9I7B,EAAAvC,QACAuC,EAAAU,QACAV,EAAA6B,WAEA7B,EAAA6I,UAAA7I,EAAAmJ,UAAAnJ,EAAA4I,YAAA5I,EAAAiI,SAAA,KACAjI,EAAAuB,WACAwH,EAAA,CAGA,IAFA/I,EAAA2B,SAAAqH,EAAAhJ,EAAA2B,OAAAlE,EAAAiD,EAAAmB,IACA7B,EAAA4J,kBAAA/H,EAAAtE,EAAAI,EAAAkE,GAAA7B,EAAA4J,oBACAnI,EAAAuH,MAAApH,EAAAoH,EAAAnH,EACA,IAAAgI,GAAAtB,EAAAuB,EAAAd,KAAA7L,QACA,IAAAe,EAAA4L,MAAApI,UAAAC,OAAA,CACA,GAAAqG,GAAAyB,EAAAM,EAAAjI,EAAAkH,EACAhB,MAAAJ,cAAAkC,EAAA1B,EAAAJ,EAAA+B,EAAA,EAAAlI,IACAgI,EAAA7B,EACAA,EAAAF,EAAAgC,EAAAC,EAAAlI,GACAmG,EAAAgC,iBAAAhK,EACAA,EAAAW,WAAAqH,EACAI,EAAAJ,EAAA+B,EAAA,EAAAlI,GACAL,EAAAwG,EAAA,IAEAO,EAAAP,EAAAO,SACiB,CACjB,GAAA0B,GAAAX,CACAO,GAAAJ,EACAI,IAAAI,EAAAjK,EAAAW,WAAA,OACA2I,GAAA,IAAAjB,KACA4B,MAAAtJ,WAAA,MACA4H,EAAApD,EAAA8E,EAAAjB,EAAAnH,EAAAwD,IAAAgE,EAAAE,KAAAD,KAAA9D,cASA,GANA8D,GAAAf,IAAAe,IAAAO,GAAAL,IAAAxJ,GAAAyJ,IAAAH,EAAA9G,aACA8G,EAAA3I,WAAA,KACA4F,EAAA+C,KAEAO,GAAArC,EAAAqC,MACA7J,EAAAuI,OACAA,EAAA,CAEA,IADA,GAAA2B,GAAAlK,EAAAO,EAAAP,EACAO,IAAAyJ,kBAAAE,EAAA3J,CACAgI,GAAA5H,WAAAuJ,EACA3B,EAAAlE,sBAAA6F,EAAAtC,cAGAyB,GAAAhE,GACAJ,GAAAkF,QAAAnK,GACAyF,IAAAT,MACa+D,GAAA/I,EAAAoK,oBAAApK,EAAAoK,mBAAAnB,EAAAC,EAAAE,EACb,IAAAiB,GAAAC,EAAAtK,EAAAuK,gBACA,IAAAD,EAAA,KAAAD,EAAAC,EAAAhJ,OAAA+I,EAAA5N,KAAAuD,EACA,OAAAgJ,IAGA,QAAA5C,GAAAhB,EAAAvF,EAAAgC,EAAAwD,GAEA,IADA,GAAA1I,GAAAyI,KAAAzE,WAAA6J,EAAApF,EAAAqF,EAAA9N,GAAAyI,EAAAf,wBAAAxE,EAAA1C,SAAAuN,EAAAD,EAAAhN,EAAAqE,EAAAjC,GACAlD,IAAA+N,IAAA/N,IAAAqN,mBAAAU,EAAA/N,EAAAiL,cAAA/H,EAAA1C,QAkBA,QAjBAuN,GAAArF,IAAA1I,EAAAgE,YAIAhE,IAAA8N,IACAjD,EAAA7K,MACAyI,EAAAoF,EAAA,MAEA7N,EAAAmL,EAAAjI,EAAA1C,SAAAM,EAAAoE,GACAuD,IAAAzI,EAAAsL,WAAAtL,EAAAsL,SAAA7C,GACAgD,EAAAzL,EAAAc,EAAA,EAAAoE,EAAAwD,GACAD,EAAAzI,EAAA4L,KACAiC,GAAApF,IAAAoF,IACAA,EAAA7J,WAAA,KACA4F,EAAAiE,MAbApC,EAAAzL,EAAAc,EAAA,EAAAoE,EAAAwD,GACAD,EAAAzI,EAAA4L,MAeAnD,EAEA,QAAAoC,GAAAxH,EAAA2K,GACA,GAAApC,GAAAvI,EAAAuI,IACAvI,GAAAwI,qBACAxI,EAAA4K,sBAAA5K,EAAA4K,uBACA5K,EAAAuI,KAAA,IACA,IAAAsC,GAAA7K,EAAAW,UACAkK,GAAArD,EAAAqD,EAAAF,GAAmDpC,IACnDA,EAAApG,KAAAoG,EAAApG,IAAAwE,KAAA4B,EAAApG,IAAAwE,IAAA,MACA3G,EAAAiI,SAAAM,EACAoC,IACApI,EAAAgG,GACAZ,EAAA3H,IAEAsH,EAAAiB,EAAA/B,YAAAmE,IAEA3K,EAAAyI,OAAAzI,EAAAyI,MAAA,MACAzI,EAAA8K,qBAAA9K,EAAA8K,sBAEA,QAAAC,GAAAtN,EAAAoE,GACA5E,KAAAsE,UACAtE,KAAAuL,qBACAvL,KAAAkM,UAAAlM,KAAA4L,UAAA5L,KAAA2L,YAAA3L,KAAAsL,KAAAtL,KAAAgL,SAAAhL,KAAA+M,iBAAA/M,KAAA0D,WAAA1D,KAAAwL,MAAAxL,KAAAoK,MAAApK,KAAA+N,cAAA/N,KAAAsN,iBAAA,KACAtN,KAAA4E,UACA5E,KAAAQ,QACAR,KAAAyD,MAAAzD,KAAAgO,iBAAAhO,KAAAgO,sBAEA,QAAAtJ,GAAA9B,EAAAyF,EAAA4F,GACA,MAAA/F,GAAA+F,EAAArL,QAAoCyF,GAEpC,GAAA6F,MACA9H,EAAA,SAAA5C,GACA,MAAA0K,GAAA1K,KAAA0K,EAAA1K,KAAA4C,gBAEA+H,EAAA,mBAAAC,kBAAAC,UACApK,EAAAkK,EAAA,SAAAG,GACAH,EAAAI,KAAAD,IACKE,WACL7L,GACAC,MAAAzB,GAEAiB,KACA0C,KACAI,GAAA,mBAAAuJ,eAAAC,IAAA,8BACA3I,IACA4I,QAAA,EACAC,aAAA,EACAC,YAAA,EACAC,YAAA,EACAC,KAAA,EACAC,SAAA,EACAC,aAAA,EACAC,WAAA,EACAC,aAAA,EACAC,WAAA,EACAC,UAAA,EACAC,WAAA,EACAC,QAAA,EACAC,MAAA,EACAC,QAAA,EACAC,cAAA,EACAC,OAAA,EACAC,OAAA,EACAC,KAAA,GAEA9L,MACAK,MACAsD,MACAM,MACAQ,GAAA,EACAY,MACAwB,KACAtK,GAAAwN,EAAArJ,WACAqL,UAAA,SAAAzP,EAAA2C,GACA,GAAAtD,GAAAM,KAAA+N,gBAAA/N,KAAA+N,kBAAkEgC,EAAA1P,EAAA,IAAA2C,CAClE,OAAAtD,GAAAqQ,KAAArQ,EAAAqQ,GAAAjN,EAAA9C,KAAAK,EAAA2C,KAEAa,SAAA,SAAAJ,EAAAuM,GACA,GAAAxM,GAAAxD,KAAAyD,KACAzD,MAAAkM,YAAAlM,KAAAkM,UAAAxL,EAAA8C,IACAlD,EAAAkD,EAAAvC,EAAAwC,KAAAD,EAAAxD,KAAAQ,OAAAiD,GACAuM,IAAAhQ,KAAAsN,iBAAAtN,KAAAsN,sBAAA9K,KAAAwN,GACA9E,EAAAlL,OAEAiQ,YAAA,WACA1L,EAAAvE,KAAA,IAEA0E,OAAA,WACA,eAGAtF,EAAAsC,IACAtC,EAAAyD,eACAzD,EAAA0O,YACA1O,EAAAsF,SACAtF,EAAA8E,WACA9E,EAAAuD,aF6DMuN,GACA,SAAS7Q,EAAQD,EAASH,GAE/B,YAcA,SAASkR,GAAuB5P,GAAO,MAAOA,IAAOA,EAAI6P,WAAa7P,GAAQ8P,QAAS9P,GAEvF,QAAS+P,GAA0B/P,GAAO,GAAW,MAAPA,EAAa,KAAM,IAAIgQ,WAAU,gCAE/E,QAASC,GAAgBC,EAAUC,GAAe,KAAMD,YAAoBC,IAAgB,KAAM,IAAIH,WAAU,qCAEhH,QAASI,GAA2BC,EAAMpR,GAAQ,IAAKoR,EAAQ,KAAM,IAAIC,gBAAe,4DAAgE,QAAOrR,GAAyB,gBAATA,IAAqC,kBAATA,GAA8BoR,EAAPpR,EAElO,QAASsR,GAAUC,EAAUC,GAAc,GAA0B,kBAAfA,IAA4C,OAAfA,EAAuB,KAAM,IAAIT,WAAU,iEAAoES,GAAeD,GAAStM,UAAYwM,OAAOC,OAAOF,GAAcA,EAAWvM,WAAakG,aAAerJ,MAAOyP,EAAUI,cAAmBC,YAAgBC,mBAA6BL,IAAYC,OAAOK,eAAiBL,OAAOK,eAAeP,EAAUC,GAAcD,EAASQ,UAAYP,GApBjeC,OAAOO,eAAepS,EAAS,cAC3BkC,UAGJ,IAAImQ,GAAe,WAAc,QAASC,GAAiBC,EAAQnR,GAAS,IAAK,GAAIC,GAAI,EAAGA,EAAID,EAAMK,OAAQJ,IAAK,CAAE,GAAImR,GAAapR,EAAMC,EAAImR,GAAWT,WAAaS,EAAWT,eAAqBS,EAAWP,gBAAyB,SAAWO,KAAYA,EAAWR,aAAiBH,OAAOO,eAAeG,EAAQC,EAAWvR,IAAKuR,IAAiB,MAAO,UAAUlB,EAAamB,EAAYC,GAAiJ,MAA9HD,IAAYH,EAAiBhB,EAAYjM,UAAWoN,GAAiBC,GAAaJ,EAAiBhB,EAAaoB,GAAqBpB,MGplBjiBqB,EAAA9S,EAAA,GACA+S,EAAA/S,EAAA,IHylBKgT,EAAc9B,EAAuB6B,GGvlBpCE,GACFC,SAAU,QACVC,OAAQ,MACRC,MAAO,MACPzC,OAAQ,WACR0C,aAAc,MACdC,OAAQ,iCACRC,MAAO,SAGLC,GACFC,OAAQ,OACRpD,WAAY,OACZqD,SAAU,OACVC,YAAa,OACbC,WAAY,mBACZC,WAAY,uBACZC,MAAO,OACPC,OAAQ,WAISC,EHkmBV,SAAUC,GAGhB,QAASD,KACL,GAAIE,GAEAC,EAAOC,EAAOC,CAElB9C,GAAgBxQ,KAAMiT,EAEtB,KAAK,GAAIM,GAAOxR,UAAUlB,OAAQ2S,EAAOC,MAAMF,GAAOG,EAAO,EAAGA,EAAOH,EAAMG,IACzEF,EAAKE,GAAQ3R,UAAU2R,EAG3B,OAAeN,GAASC,EAAQ1C,EAA2B3Q,MAAOmT,EAAOF,EAAI1B,WAAaN,OAAO0C,eAAeV,IAAMzT,KAAKoU,MAAMT,GAAOnT,MAAM6T,OAAOL,KAAiBH,EG9mB3K5P,OACIqQ,YACAC,eH+mBIV,EG1lBRW,QAAU,WACN,MAAKC,QAAOC,gBAKZb,GAAKxP,UACDiQ,YACAC,YAAaV,EAAK5P,MAAMsQ,iBANxBI,SAAQC,MAAM,qDHqlBVd,EAaJF,EAAQzC,EAA2B0C,EAAOC,GA2BjD,MArDAxC,GAAUmC,EAAKC,GA6BfzB,EAAawB,IACT5S,IAAK,SACLiB,MAAO,SAAgB+S,EAAOC,GG1nB/B,MADUhE,GAAAgE,GAAAhE,EAAA+D,MAENtC,EAAArQ,GAAA,OAAKmE,MAAOqM,MAGRH,EAAArQ,GAAA,OAAKmE,MAAO4M,EAAYuB,QAAShU,KAAKgU,SAChChU,KAAKyD,MAAMsQ,WAAwC,YAA3B,6BAI9BhC,EAAArQ,GAAA,OAAKmE,OAAQ0O,QAASvU,KAAKyD,MAAMsQ,WAAa,QAAU,SACnD/T,KAAKyD,MAAMqQ,SAAW,QAAO/B,EAAArQ,GAAAuQ,EAAA5B,QAAA,YHsoBtC4C,GACTlB,EAAQjE,UAEV1O,GAAQiR,QG3pBY4C,GH+pBfuB,GACA,SAASnV,EAAQD,EAASH,GAE/B,YAUA,SAASuR,GAAgBC,EAAUC,GAAe,KAAMD,YAAoBC,IAAgB,KAAM,IAAIH,WAAU,qCAEhH,QAASI,GAA2BC,EAAMpR,GAAQ,IAAKoR,EAAQ,KAAM,IAAIC,gBAAe,4DAAgE,QAAOrR,GAAyB,gBAATA,IAAqC,kBAATA,GAA8BoR,EAAPpR,EAElO,QAASsR,GAAUC,EAAUC,GAAc,GAA0B,kBAAfA,IAA4C,OAAfA,EAAuB,KAAM,IAAIT,WAAU,iEAAoES,GAAeD,GAAStM,UAAYwM,OAAOC,OAAOF,GAAcA,EAAWvM,WAAakG,aAAerJ,MAAOyP,EAAUI,cAAmBC,YAAgBC,mBAA6BL,IAAYC,OAAOK,eAAiBL,OAAOK,eAAeP,EAAUC,GAAcD,EAASQ,UAAYP,GAZjeC,OAAOO,eAAepS,EAAS,cAC3BkC,UAGJ,IAAImQ,GAAe,WAAc,QAASC,GAAiBC,EAAQnR,GAAS,IAAK,GAAIC,GAAI,EAAGA,EAAID,EAAMK,OAAQJ,IAAK,CAAE,GAAImR,GAAapR,EAAMC,EAAImR,GAAWT,WAAaS,EAAWT,eAAqBS,EAAWP,gBAAyB,SAAWO,KAAYA,EAAWR,aAAiBH,OAAOO,eAAeG,EAAQC,EAAWvR,IAAKuR,IAAiB,MAAO,UAAUlB,EAAamB,EAAYC,GAAiJ,MAA9HD,IAAYH,EAAiBhB,EAAYjM,UAAWoN,GAAiBC,GAAaJ,EAAiBhB,EAAaoB,GAAqBpB,MIjsBjiBqB,EAAA9S,EAAA,GAEqBwV,EJysBJ,SAAUvB,GAGtB,QAASuB,KAGL,MAFAjE,GAAgBxQ,KAAMyU,GAEf9D,EAA2B3Q,MAAOyU,EAAUlD,WAAaN,OAAO0C,eAAec,IAAYb,MAAM5T,KAAM+B,YAoBlH,MAzBA+O,GAAU2D,EAAWvB,GAQrBzB,EAAagD,IACTpU,IAAK,wBACLiB,MAAO,WIhtBR,YJqtBCjB,IAAK,SACLiB,MAAO,WIltBR,SAEIyQ,EAAArQ,GAAA,UAAQgT,IAAK,kDAAoDT,OAAOC,YAChE1B,MAAM,MAAME,OAAO,MAAMiC,YAAY,UJwtB7CF,GACT1C,EAAQjE,UAEV1O,GAAQiR,QItuBYoE,GJ0uBfG,GACA,SAASvV,EAAQD,EAASH,GAE/B,YAQA,SAASkR,GAAuB5P,GAAO,MAAOA,IAAOA,EAAI6P,WAAa7P,GAAQ8P,QAAS9P,GK9uBxF,QAASsU,KACL,GAAIC,GAAOlN,SAASE,cAAc,MAClCgN,GAAKxV,GAAK,gBACVsI,SAASmN,qBAAqB,QAAQ,GAAG1L,YAAYyL,MACrD/C,EAAArN,WAAOqN,EAAArQ,GAAAsT,EAAA3E,QAAA,MAASyE,GAbpB,GAAA/C,GAAA9S,EAAA,GACAgW,EAAAhW,EAAA,ILovBK+V,EAAQ7E,EAAuB8E,EKlvBhChB,QAAOiB,YACPjB,OAAOiB,YAAY,SAAUL,GAE7BZ,OAAO3N,iBAAiB,OAAQuO","file":"widget.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/static/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(33);\n\n\n/***/ },\n\n/***/ 1:\n/***/ function(module, exports, __webpack_require__) {\n\n\t!function(global, factory) {\n\t     true ? factory(exports) : 'function' == typeof define && define.amd ? define([ 'exports' ], factory) : factory(global.preact = global.preact || {});\n\t}(this, function(exports) {\n\t    function VNode(nodeName, attributes, children) {\n\t        this.nodeName = nodeName;\n\t        this.attributes = attributes;\n\t        this.children = children;\n\t        this.key = attributes && attributes.key;\n\t    }\n\t    function extend(obj, props) {\n\t        if (props) for (var i in props) if (void 0 !== props[i]) obj[i] = props[i];\n\t        return obj;\n\t    }\n\t    function clone(obj) {\n\t        return extend({}, obj);\n\t    }\n\t    function delve(obj, key) {\n\t        for (var p = key.split('.'), i = 0; i < p.length && obj; i++) obj = obj[p[i]];\n\t        return obj;\n\t    }\n\t    function toArray(obj, offset) {\n\t        return [].slice.call(obj, offset);\n\t    }\n\t    function isFunction(obj) {\n\t        return 'function' == typeof obj;\n\t    }\n\t    function isString(obj) {\n\t        return 'string' == typeof obj;\n\t    }\n\t    function empty(x) {\n\t        return void 0 === x || null === x;\n\t    }\n\t    function falsey(value) {\n\t        return value === !1 || empty(value);\n\t    }\n\t    function hashToClassName(c) {\n\t        var str = '';\n\t        for (var prop in c) if (c[prop]) {\n\t            if (str) str += ' ';\n\t            str += prop;\n\t        }\n\t        return str;\n\t    }\n\t    function h(nodeName, attributes, firstChild) {\n\t        var children, arr, lastSimple, len = arguments.length;\n\t        if (len > 2) {\n\t            var type = typeof firstChild;\n\t            if (3 === len && 'object' !== type && 'function' !== type) {\n\t                if (!falsey(firstChild)) children = [ String(firstChild) ];\n\t            } else {\n\t                children = [];\n\t                for (var i = 2; i < len; i++) {\n\t                    var _p = arguments[i];\n\t                    if (!falsey(_p)) {\n\t                        if (_p.join) arr = _p; else (arr = SHARED_TEMP_ARRAY)[0] = _p;\n\t                        for (var j = 0; j < arr.length; j++) {\n\t                            var child = arr[j], simple = !(falsey(child) || isFunction(child) || child instanceof VNode);\n\t                            if (simple && !isString(child)) child = String(child);\n\t                            if (simple && lastSimple) children[children.length - 1] += child; else if (!falsey(child)) {\n\t                                children.push(child);\n\t                                lastSimple = simple;\n\t                            }\n\t                        }\n\t                    } else ;\n\t                }\n\t            }\n\t        } else if (attributes && attributes.children) return h(nodeName, attributes, attributes.children);\n\t        if (attributes) {\n\t            if (attributes.children) delete attributes.children;\n\t            if (!isFunction(nodeName)) {\n\t                if ('className' in attributes) {\n\t                    attributes.class = attributes.className;\n\t                    delete attributes.className;\n\t                }\n\t                lastSimple = attributes.class;\n\t                if (lastSimple && !isString(lastSimple)) attributes.class = hashToClassName(lastSimple);\n\t            }\n\t        }\n\t        var p = new VNode(nodeName, attributes || void 0, children);\n\t        if (options.vnode) options.vnode(p);\n\t        return p;\n\t    }\n\t    function cloneElement(vnode, props) {\n\t        return h(vnode.nodeName, extend(clone(vnode.attributes), props), arguments.length > 2 ? toArray(arguments, 2) : vnode.children);\n\t    }\n\t    function createLinkedState(component, key, eventPath) {\n\t        var path = key.split('.'), p0 = path[0];\n\t        return function(e) {\n\t            var _component$setState;\n\t            var v, i, t = e && e.currentTarget || this, s = component.state, obj = s;\n\t            if (isString(eventPath)) {\n\t                v = delve(e, eventPath);\n\t                if (empty(v) && (t = t._component)) v = delve(t, eventPath);\n\t            } else v = t.nodeName ? (t.nodeName + t.type).match(/^input(check|rad)/i) ? t.checked : t.value : e;\n\t            if (isFunction(v)) v = v.call(t);\n\t            if (path.length > 1) {\n\t                for (i = 0; i < path.length - 1; i++) obj = obj[path[i]] || (obj[path[i]] = {});\n\t                obj[path[i]] = v;\n\t                v = s[p0];\n\t            }\n\t            component.setState((_component$setState = {}, _component$setState[p0] = v, _component$setState));\n\t        };\n\t    }\n\t    function enqueueRender(component) {\n\t        if (1 === items.push(component)) (options.debounceRendering || defer)(rerender);\n\t    }\n\t    function rerender() {\n\t        if (items.length) {\n\t            var p, currentItems = items;\n\t            items = itemsOffline;\n\t            itemsOffline = currentItems;\n\t            while (p = currentItems.pop()) if (p._dirty) renderComponent(p);\n\t        }\n\t    }\n\t    function isFunctionalComponent(vnode) {\n\t        var nodeName = vnode && vnode.nodeName;\n\t        return nodeName && isFunction(nodeName) && !(nodeName.prototype && nodeName.prototype.render);\n\t    }\n\t    function buildFunctionalComponent(vnode, context) {\n\t        return vnode.nodeName(getNodeProps(vnode), context || EMPTY);\n\t    }\n\t    function ensureNodeData(node, data) {\n\t        return node[ATTR_KEY] || (node[ATTR_KEY] = data || {});\n\t    }\n\t    function getNodeType(node) {\n\t        if (node instanceof Text) return 3;\n\t        if (node instanceof Element) return 1; else return 0;\n\t    }\n\t    function removeNode(node) {\n\t        var p = node.parentNode;\n\t        if (p) p.removeChild(node);\n\t    }\n\t    function setAccessor(node, name, value, old, isSvg) {\n\t        ensureNodeData(node)[name] = value;\n\t        if ('key' !== name && 'children' !== name && 'innerHTML' !== name) if ('class' === name && !isSvg) node.className = value || ''; else if ('style' === name) {\n\t            if (!value || isString(value) || isString(old)) node.style.cssText = value || '';\n\t            if (value && 'object' == typeof value) {\n\t                if (!isString(old)) for (var i in old) if (!(i in value)) node.style[i] = '';\n\t                for (var i in value) node.style[i] = 'number' == typeof value[i] && !NON_DIMENSION_PROPS[i] ? value[i] + 'px' : value[i];\n\t            }\n\t        } else if ('dangerouslySetInnerHTML' === name) {\n\t            if (value) node.innerHTML = value.__html;\n\t        } else if (name.match(/^on/i)) {\n\t            var l = node._listeners || (node._listeners = {});\n\t            name = toLowerCase(name.substring(2));\n\t            if (value) {\n\t                if (!l[name]) node.addEventListener(name, eventProxy);\n\t            } else if (l[name]) node.removeEventListener(name, eventProxy);\n\t            l[name] = value;\n\t        } else if ('type' !== name && !isSvg && name in node) {\n\t            setProperty(node, name, empty(value) ? '' : value);\n\t            if (falsey(value)) node.removeAttribute(name);\n\t        } else {\n\t            var ns = isSvg && name.match(/^xlink\\:?(.+)/);\n\t            if (falsey(value)) if (ns) node.removeAttributeNS('http://www.w3.org/1999/xlink', toLowerCase(ns[1])); else node.removeAttribute(name); else if ('object' != typeof value && !isFunction(value)) if (ns) node.setAttributeNS('http://www.w3.org/1999/xlink', toLowerCase(ns[1]), value); else node.setAttribute(name, value);\n\t        }\n\t    }\n\t    function setProperty(node, name, value) {\n\t        try {\n\t            node[name] = value;\n\t        } catch (e) {}\n\t    }\n\t    function eventProxy(e) {\n\t        return this._listeners[e.type](options.event && options.event(e) || e);\n\t    }\n\t    function getRawNodeAttributes(node) {\n\t        var attrs = {};\n\t        for (var i = node.attributes.length; i--; ) attrs[node.attributes[i].name] = node.attributes[i].value;\n\t        return attrs;\n\t    }\n\t    function isSameNodeType(node, vnode) {\n\t        if (isString(vnode)) return 3 === getNodeType(node);\n\t        if (isString(vnode.nodeName)) return isNamedNode(node, vnode.nodeName);\n\t        if (isFunction(vnode.nodeName)) return node._componentConstructor === vnode.nodeName || isFunctionalComponent(vnode); else ;\n\t    }\n\t    function isNamedNode(node, nodeName) {\n\t        return node.normalizedNodeName === nodeName || toLowerCase(node.nodeName) === toLowerCase(nodeName);\n\t    }\n\t    function getNodeProps(vnode) {\n\t        var defaultProps = vnode.nodeName.defaultProps, props = clone(defaultProps || vnode.attributes);\n\t        if (defaultProps) extend(props, vnode.attributes);\n\t        if (vnode.children) props.children = vnode.children;\n\t        return props;\n\t    }\n\t    function collectNode(node) {\n\t        cleanNode(node);\n\t        var name = toLowerCase(node.nodeName), list = nodes[name];\n\t        if (list) list.push(node); else nodes[name] = [ node ];\n\t    }\n\t    function createNode(nodeName, isSvg) {\n\t        var name = toLowerCase(nodeName), node = nodes[name] && nodes[name].pop() || (isSvg ? document.createElementNS('http://www.w3.org/2000/svg', nodeName) : document.createElement(nodeName));\n\t        ensureNodeData(node);\n\t        node.normalizedNodeName = name;\n\t        return node;\n\t    }\n\t    function cleanNode(node) {\n\t        removeNode(node);\n\t        if (1 === getNodeType(node)) {\n\t            ensureNodeData(node, getRawNodeAttributes(node));\n\t            node._component = node._componentConstructor = null;\n\t        }\n\t    }\n\t    function flushMounts() {\n\t        var c;\n\t        while (c = mounts.pop()) if (c.componentDidMount) c.componentDidMount();\n\t    }\n\t    function diff(dom, vnode, context, mountAll, parent, rootComponent, nextSibling) {\n\t        diffLevel++;\n\t        var ret = idiff(dom, vnode, context, mountAll, rootComponent);\n\t        if (parent && ret.parentNode !== parent) parent.insertBefore(ret, nextSibling || null);\n\t        if (!--diffLevel) flushMounts();\n\t        return ret;\n\t    }\n\t    function idiff(dom, vnode, context, mountAll, rootComponent) {\n\t        var originalAttributes = vnode && vnode.attributes;\n\t        while (isFunctionalComponent(vnode)) vnode = buildFunctionalComponent(vnode, context);\n\t        if (empty(vnode)) {\n\t            vnode = '';\n\t            if (rootComponent) {\n\t                if (dom) {\n\t                    if (8 === dom.nodeType) return dom;\n\t                    collectNode(dom);\n\t                }\n\t                return document.createComment(vnode);\n\t            }\n\t        }\n\t        if (isString(vnode)) {\n\t            if (dom) {\n\t                if (3 === getNodeType(dom) && dom.parentNode) {\n\t                    dom.nodeValue = vnode;\n\t                    return dom;\n\t                }\n\t                collectNode(dom);\n\t            }\n\t            return document.createTextNode(vnode);\n\t        }\n\t        var svgMode, out = dom, nodeName = vnode.nodeName;\n\t        if (isFunction(nodeName)) return buildComponentFromVNode(dom, vnode, context, mountAll);\n\t        if (!isString(nodeName)) nodeName = String(nodeName);\n\t        svgMode = 'svg' === toLowerCase(nodeName);\n\t        if (svgMode) isSvgMode = !0;\n\t        if (!dom) out = createNode(nodeName, isSvgMode); else if (!isNamedNode(dom, nodeName)) {\n\t            out = createNode(nodeName, isSvgMode);\n\t            while (dom.firstChild) out.appendChild(dom.firstChild);\n\t            recollectNodeTree(dom);\n\t        }\n\t        if (vnode.children && 1 === vnode.children.length && 'string' == typeof vnode.children[0] && 1 === out.childNodes.length && out.firstChild instanceof Text) out.firstChild.nodeValue = vnode.children[0]; else if (vnode.children || out.firstChild) innerDiffNode(out, vnode.children, context, mountAll);\n\t        diffAttributes(out, vnode.attributes);\n\t        if (originalAttributes && originalAttributes.ref) (out[ATTR_KEY].ref = originalAttributes.ref)(out);\n\t        if (svgMode) isSvgMode = !1;\n\t        return out;\n\t    }\n\t    function innerDiffNode(dom, vchildren, context, mountAll) {\n\t        var j, c, vchild, child, originalChildren = dom.childNodes, children = [], keyed = {}, keyedLen = 0, min = 0, len = originalChildren.length, childrenLen = 0, vlen = vchildren && vchildren.length;\n\t        if (len) for (var i = 0; i < len; i++) {\n\t            var _child = originalChildren[i], key = vlen ? (c = _child._component) ? c.__key : (c = _child[ATTR_KEY]) ? c.key : null : null;\n\t            if (key || 0 === key) {\n\t                keyedLen++;\n\t                keyed[key] = _child;\n\t            } else children[childrenLen++] = _child;\n\t        }\n\t        if (vlen) for (var i = 0; i < vlen; i++) {\n\t            vchild = vchildren[i];\n\t            child = null;\n\t            if (keyedLen && vchild.attributes) {\n\t                var key = vchild.key;\n\t                if (!empty(key) && key in keyed) {\n\t                    child = keyed[key];\n\t                    keyed[key] = void 0;\n\t                    keyedLen--;\n\t                }\n\t            }\n\t            if (!child && min < childrenLen) for (j = min; j < childrenLen; j++) {\n\t                c = children[j];\n\t                if (c && isSameNodeType(c, vchild)) {\n\t                    child = c;\n\t                    children[j] = void 0;\n\t                    if (j === childrenLen - 1) childrenLen--;\n\t                    if (j === min) min++;\n\t                    break;\n\t                }\n\t            }\n\t            child = idiff(child, vchild, context, mountAll);\n\t            if (child !== originalChildren[i]) dom.insertBefore(child, originalChildren[i] || null);\n\t        }\n\t        if (keyedLen) for (var i in keyed) if (keyed[i]) children[min = childrenLen++] = keyed[i];\n\t        if (min < childrenLen) removeOrphanedChildren(children);\n\t    }\n\t    function removeOrphanedChildren(children, unmountOnly) {\n\t        for (var i = children.length; i--; ) {\n\t            var child = children[i];\n\t            if (child) recollectNodeTree(child, unmountOnly);\n\t        }\n\t    }\n\t    function recollectNodeTree(node, unmountOnly) {\n\t        var component = node._component;\n\t        if (component) unmountComponent(component, !unmountOnly); else {\n\t            if (node[ATTR_KEY] && node[ATTR_KEY].ref) node[ATTR_KEY].ref(null);\n\t            if (!unmountOnly) collectNode(node);\n\t            if (node.childNodes && node.childNodes.length) removeOrphanedChildren(node.childNodes, unmountOnly);\n\t        }\n\t    }\n\t    function diffAttributes(dom, attrs) {\n\t        var old = dom[ATTR_KEY] || getRawNodeAttributes(dom);\n\t        for (var _name in old) if (!(attrs && _name in attrs)) setAccessor(dom, _name, null, old[_name], isSvgMode);\n\t        if (attrs) for (var _name2 in attrs) if (!(_name2 in old) || attrs[_name2] != old[_name2] || ('value' === _name2 || 'checked' === _name2) && attrs[_name2] != dom[_name2]) setAccessor(dom, _name2, attrs[_name2], old[_name2], isSvgMode);\n\t    }\n\t    function collectComponent(component) {\n\t        var name = component.constructor.name, list = components[name];\n\t        if (list) list.push(component); else components[name] = [ component ];\n\t    }\n\t    function createComponent(Ctor, props, context) {\n\t        var inst = new Ctor(props, context), list = components[Ctor.name];\n\t        inst.props = props;\n\t        inst.context = context;\n\t        if (list) for (var i = list.length; i--; ) if (list[i].constructor === Ctor) {\n\t            inst.nextBase = list[i].nextBase;\n\t            list.splice(i, 1);\n\t            break;\n\t        }\n\t        return inst;\n\t    }\n\t    function triggerComponentRender(component) {\n\t        if (!component._dirty) {\n\t            component._dirty = !0;\n\t            enqueueRender(component);\n\t        }\n\t    }\n\t    function setComponentProps(component, props, opts, context, mountAll) {\n\t        var b = component.base;\n\t        if (!component._disableRendering) {\n\t            component._disableRendering = !0;\n\t            if (component.__ref = props.ref) delete props.ref;\n\t            if (component.__key = props.key) delete props.key;\n\t            if (empty(b) || mountAll) {\n\t                if (component.componentWillMount) component.componentWillMount();\n\t            } else if (component.componentWillReceiveProps) component.componentWillReceiveProps(props, context);\n\t            if (context && context !== component.context) {\n\t                if (!component.prevContext) component.prevContext = component.context;\n\t                component.context = context;\n\t            }\n\t            if (!component.prevProps) component.prevProps = component.props;\n\t            component.props = props;\n\t            component._disableRendering = !1;\n\t            if (0 !== opts) if (1 === opts || options.syncComponentUpdates !== !1 || !b) renderComponent(component, 1, mountAll); else triggerComponentRender(component);\n\t            if (component.__ref) component.__ref(component);\n\t        }\n\t    }\n\t    function renderComponent(component, opts, mountAll) {\n\t        if (!component._disableRendering) {\n\t            var skip, rendered, props = component.props, state = component.state, context = component.context, previousProps = component.prevProps || props, previousState = component.prevState || state, previousContext = component.prevContext || context, isUpdate = component.base, initialBase = isUpdate || component.nextBase, baseParent = initialBase && initialBase.parentNode, initialComponent = initialBase && initialBase._component, initialChildComponent = component._component;\n\t            if (isUpdate) {\n\t                component.props = previousProps;\n\t                component.state = previousState;\n\t                component.context = previousContext;\n\t                if (2 !== opts && component.shouldComponentUpdate && component.shouldComponentUpdate(props, state, context) === !1) skip = !0; else if (component.componentWillUpdate) component.componentWillUpdate(props, state, context);\n\t                component.props = props;\n\t                component.state = state;\n\t                component.context = context;\n\t            }\n\t            component.prevProps = component.prevState = component.prevContext = component.nextBase = null;\n\t            component._dirty = !1;\n\t            if (!skip) {\n\t                if (component.render) rendered = component.render(props, state, context);\n\t                if (component.getChildContext) context = extend(clone(context), component.getChildContext());\n\t                while (isFunctionalComponent(rendered)) rendered = buildFunctionalComponent(rendered, context);\n\t                var toUnmount, base, childComponent = rendered && rendered.nodeName;\n\t                if (isFunction(childComponent) && childComponent.prototype.render) {\n\t                    var inst = initialChildComponent, childProps = getNodeProps(rendered);\n\t                    if (inst && inst.constructor === childComponent) setComponentProps(inst, childProps, 1, context); else {\n\t                        toUnmount = inst;\n\t                        inst = createComponent(childComponent, childProps, context);\n\t                        inst._parentComponent = component;\n\t                        component._component = inst;\n\t                        setComponentProps(inst, childProps, 0, context);\n\t                        renderComponent(inst, 1);\n\t                    }\n\t                    base = inst.base;\n\t                } else {\n\t                    var cbase = initialBase;\n\t                    toUnmount = initialChildComponent;\n\t                    if (toUnmount) cbase = component._component = null;\n\t                    if (initialBase || 1 === opts) {\n\t                        if (cbase) cbase._component = null;\n\t                        base = diff(cbase, rendered, context, mountAll || !isUpdate, baseParent, !0, initialBase && initialBase.nextSibling);\n\t                    }\n\t                }\n\t                if (initialBase && base !== initialBase) if (!toUnmount && initialComponent === component && !initialChildComponent && initialBase.parentNode) {\n\t                    initialBase._component = null;\n\t                    recollectNodeTree(initialBase);\n\t                }\n\t                if (toUnmount) unmountComponent(toUnmount, !0);\n\t                component.base = base;\n\t                if (base) {\n\t                    var componentRef = component, t = component;\n\t                    while (t = t._parentComponent) componentRef = t;\n\t                    base._component = componentRef;\n\t                    base._componentConstructor = componentRef.constructor;\n\t                }\n\t            }\n\t            if (!isUpdate || mountAll) {\n\t                mounts.unshift(component);\n\t                if (!diffLevel) flushMounts();\n\t            } else if (!skip && component.componentDidUpdate) component.componentDidUpdate(previousProps, previousState, previousContext);\n\t            var fn, cb = component._renderCallbacks;\n\t            if (cb) while (fn = cb.pop()) fn.call(component);\n\t            return rendered;\n\t        }\n\t    }\n\t    function buildComponentFromVNode(dom, vnode, context, mountAll) {\n\t        var c = dom && dom._component, oldDom = dom, isDirectOwner = c && dom._componentConstructor === vnode.nodeName, isOwner = isDirectOwner, props = getNodeProps(vnode);\n\t        while (c && !isOwner && (c = c._parentComponent)) isOwner = c.constructor === vnode.nodeName;\n\t        if (isOwner && (!mountAll || c._component)) {\n\t            setComponentProps(c, props, 3, context, mountAll);\n\t            dom = c.base;\n\t        } else {\n\t            if (c && !isDirectOwner) {\n\t                unmountComponent(c, !0);\n\t                dom = oldDom = null;\n\t            }\n\t            c = createComponent(vnode.nodeName, props, context);\n\t            if (dom && !c.nextBase) c.nextBase = dom;\n\t            setComponentProps(c, props, 1, context, mountAll);\n\t            dom = c.base;\n\t            if (oldDom && dom !== oldDom) {\n\t                oldDom._component = null;\n\t                recollectNodeTree(oldDom);\n\t            }\n\t        }\n\t        return dom;\n\t    }\n\t    function unmountComponent(component, remove) {\n\t        var base = component.base;\n\t        component._disableRendering = !0;\n\t        if (component.componentWillUnmount) component.componentWillUnmount();\n\t        component.base = null;\n\t        var inner = component._component;\n\t        if (inner) unmountComponent(inner, remove); else if (base) {\n\t            if (base[ATTR_KEY] && base[ATTR_KEY].ref) base[ATTR_KEY].ref(null);\n\t            component.nextBase = base;\n\t            if (remove) {\n\t                removeNode(base);\n\t                collectComponent(component);\n\t            }\n\t            removeOrphanedChildren(base.childNodes, !remove);\n\t        }\n\t        if (component.__ref) component.__ref(null);\n\t        if (component.componentDidUnmount) component.componentDidUnmount();\n\t    }\n\t    function Component(props, context) {\n\t        this._dirty = !0;\n\t        this._disableRendering = !1;\n\t        this.prevState = this.prevProps = this.prevContext = this.base = this.nextBase = this._parentComponent = this._component = this.__ref = this.__key = this._linkedStates = this._renderCallbacks = null;\n\t        this.context = context;\n\t        this.props = props;\n\t        this.state = this.getInitialState && this.getInitialState() || {};\n\t    }\n\t    function render(vnode, parent, merge) {\n\t        return diff(merge, vnode, {}, !1, parent);\n\t    }\n\t    var lcCache = {};\n\t    var toLowerCase = function(s) {\n\t        return lcCache[s] || (lcCache[s] = s.toLowerCase());\n\t    };\n\t    var resolved = 'undefined' != typeof Promise && Promise.resolve();\n\t    var defer = resolved ? function(f) {\n\t        resolved.then(f);\n\t    } : setTimeout;\n\t    var options = {\n\t        vnode: empty\n\t    };\n\t    var SHARED_TEMP_ARRAY = [];\n\t    var EMPTY = {};\n\t    var ATTR_KEY = 'undefined' != typeof Symbol ? Symbol.for('preactattr') : '__preactattr_';\n\t    var NON_DIMENSION_PROPS = {\n\t        boxFlex: 1,\n\t        boxFlexGroup: 1,\n\t        columnCount: 1,\n\t        fillOpacity: 1,\n\t        flex: 1,\n\t        flexGrow: 1,\n\t        flexPositive: 1,\n\t        flexShrink: 1,\n\t        flexNegative: 1,\n\t        fontWeight: 1,\n\t        lineClamp: 1,\n\t        lineHeight: 1,\n\t        opacity: 1,\n\t        order: 1,\n\t        orphans: 1,\n\t        strokeOpacity: 1,\n\t        widows: 1,\n\t        zIndex: 1,\n\t        zoom: 1\n\t    };\n\t    var items = [];\n\t    var itemsOffline = [];\n\t    var nodes = {};\n\t    var mounts = [];\n\t    var diffLevel = 0;\n\t    var isSvgMode = !1;\n\t    var components = {};\n\t    extend(Component.prototype, {\n\t        linkState: function(key, eventPath) {\n\t            var c = this._linkedStates || (this._linkedStates = {}), cacheKey = key + '|' + eventPath;\n\t            return c[cacheKey] || (c[cacheKey] = createLinkedState(this, key, eventPath));\n\t        },\n\t        setState: function(state, callback) {\n\t            var s = this.state;\n\t            if (!this.prevState) this.prevState = clone(s);\n\t            extend(s, isFunction(state) ? state(s, this.props) : state);\n\t            if (callback) (this._renderCallbacks = this._renderCallbacks || []).push(callback);\n\t            triggerComponentRender(this);\n\t        },\n\t        forceUpdate: function() {\n\t            renderComponent(this, 2);\n\t        },\n\t        render: function() {\n\t            return null;\n\t        }\n\t    });\n\t    exports.h = h;\n\t    exports.cloneElement = cloneElement;\n\t    exports.Component = Component;\n\t    exports.render = render;\n\t    exports.rerender = rerender;\n\t    exports.options = options;\n\t});\n\t//# sourceMappingURL=preact.js.map\n\n/***/ },\n\n/***/ 31:\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _preact = __webpack_require__(1);\n\t\n\tvar _ChatFrame = __webpack_require__(32);\n\t\n\tvar _ChatFrame2 = _interopRequireDefault(_ChatFrame);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _objectDestructuringEmpty(obj) { if (obj == null) throw new TypeError(\"Cannot destructure undefined\"); }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar wrapperStyle = {\n\t    position: 'fixed',\n\t    bottom: '0px',\n\t    right: '4px',\n\t    zIndex: 2147483647,\n\t    borderRadius: '5px',\n\t    border: '1px solid rgba(82,179,217,0.9)',\n\t    width: '300px'\n\t};\n\t\n\tvar titleStyle = {\n\t    height: '30px',\n\t    lineHeight: '30px',\n\t    fontSize: '20px',\n\t    paddingLeft: '10px',\n\t    fontFamily: 'Lato, sans-serif',\n\t    background: 'rgba(82,179,217,0.9)',\n\t    color: '#fff',\n\t    cursor: 'pointer'\n\t};\n\t\n\tvar App = function (_Component) {\n\t    _inherits(App, _Component);\n\t\n\t    function App() {\n\t        var _ref;\n\t\n\t        var _temp, _this, _ret;\n\t\n\t        _classCallCheck(this, App);\n\t\n\t        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t            args[_key] = arguments[_key];\n\t        }\n\t\n\t        return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = App.__proto__ || Object.getPrototypeOf(App)).call.apply(_ref, [this].concat(args))), _this), _this.state = {\n\t            pristine: true,\n\t            isChatOpen: false\n\t        }, _this.onClick = function () {\n\t            if (!window.intergramId) {\n\t                console.error(\"To use Intergram you have to set an intergramId \");\n\t                return;\n\t            }\n\t\n\t            _this.setState({\n\t                pristine: false,\n\t                isChatOpen: !_this.state.isChatOpen\n\t            });\n\t        }, _temp), _possibleConstructorReturn(_this, _ret);\n\t    }\n\t\n\t    _createClass(App, [{\n\t        key: 'render',\n\t        value: function render(_ref2, _ref3) {\n\t            _objectDestructuringEmpty(_ref3);\n\t\n\t            _objectDestructuringEmpty(_ref2);\n\t\n\t            return (0, _preact.h)(\n\t                'div',\n\t                { style: wrapperStyle },\n\t                (0, _preact.h)(\n\t                    'div',\n\t                    { style: titleStyle, onClick: this.onClick },\n\t                    !this.state.isChatOpen ? \"Click to chat with us!\" : \"Intergram\"\n\t                ),\n\t                (0, _preact.h)(\n\t                    'div',\n\t                    { style: { display: this.state.isChatOpen ? 'block' : 'none' } },\n\t                    this.state.pristine ? null : (0, _preact.h)(_ChatFrame2.default, null)\n\t                )\n\t            );\n\t        }\n\t    }]);\n\t\n\t    return App;\n\t}(_preact.Component);\n\t\n\texports.default = App;\n\n/***/ },\n\n/***/ 32:\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _preact = __webpack_require__(1);\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar ChatFrame = function (_Component) {\n\t    _inherits(ChatFrame, _Component);\n\t\n\t    function ChatFrame() {\n\t        _classCallCheck(this, ChatFrame);\n\t\n\t        return _possibleConstructorReturn(this, (ChatFrame.__proto__ || Object.getPrototypeOf(ChatFrame)).apply(this, arguments));\n\t    }\n\t\n\t    _createClass(ChatFrame, [{\n\t        key: 'shouldComponentUpdate',\n\t        value: function shouldComponentUpdate() {\n\t            // do not re-render via diff:\n\t            return false;\n\t        }\n\t    }, {\n\t        key: 'render',\n\t        value: function render() {\n\t            return (\n\t                // Using a static link to GitHub pages - this might be confusing during development!\n\t                (0, _preact.h)('iframe', { src: 'https://idoco.github.io/intergram/chat.html?id=' + window.intergramId,\n\t                    width: '300', height: '350', frameborder: '0' })\n\t            );\n\t        }\n\t    }]);\n\t\n\t    return ChatFrame;\n\t}(_preact.Component);\n\t\n\texports.default = ChatFrame;\n\n/***/ },\n\n/***/ 33:\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _preact = __webpack_require__(1);\n\t\n\tvar _App = __webpack_require__(31);\n\t\n\tvar _App2 = _interopRequireDefault(_App);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tif (window.attachEvent) {\n\t    window.attachEvent('onload', injectChat);\n\t} else {\n\t    window.addEventListener('load', injectChat, false);\n\t}\n\t\n\tfunction injectChat() {\n\t    var root = document.createElement('div');\n\t    root.id = 'intergramRoot';\n\t    document.getElementsByTagName('body')[0].appendChild(root);\n\t    (0, _preact.render)((0, _preact.h)(_App2.default, null), root);\n\t}\n\n/***/ }\n\n/******/ });\n\n\n// WEBPACK FOOTER //\n// widget.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/static/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 0355b12dce7bac8e52bc","!function(global, factory) {\n    'object' == typeof exports && 'undefined' != typeof module ? factory(exports) : 'function' == typeof define && define.amd ? define([ 'exports' ], factory) : factory(global.preact = global.preact || {});\n}(this, function(exports) {\n    function VNode(nodeName, attributes, children) {\n        this.nodeName = nodeName;\n        this.attributes = attributes;\n        this.children = children;\n        this.key = attributes && attributes.key;\n    }\n    function extend(obj, props) {\n        if (props) for (var i in props) if (void 0 !== props[i]) obj[i] = props[i];\n        return obj;\n    }\n    function clone(obj) {\n        return extend({}, obj);\n    }\n    function delve(obj, key) {\n        for (var p = key.split('.'), i = 0; i < p.length && obj; i++) obj = obj[p[i]];\n        return obj;\n    }\n    function toArray(obj, offset) {\n        return [].slice.call(obj, offset);\n    }\n    function isFunction(obj) {\n        return 'function' == typeof obj;\n    }\n    function isString(obj) {\n        return 'string' == typeof obj;\n    }\n    function empty(x) {\n        return void 0 === x || null === x;\n    }\n    function falsey(value) {\n        return value === !1 || empty(value);\n    }\n    function hashToClassName(c) {\n        var str = '';\n        for (var prop in c) if (c[prop]) {\n            if (str) str += ' ';\n            str += prop;\n        }\n        return str;\n    }\n    function h(nodeName, attributes, firstChild) {\n        var children, arr, lastSimple, len = arguments.length;\n        if (len > 2) {\n            var type = typeof firstChild;\n            if (3 === len && 'object' !== type && 'function' !== type) {\n                if (!falsey(firstChild)) children = [ String(firstChild) ];\n            } else {\n                children = [];\n                for (var i = 2; i < len; i++) {\n                    var _p = arguments[i];\n                    if (!falsey(_p)) {\n                        if (_p.join) arr = _p; else (arr = SHARED_TEMP_ARRAY)[0] = _p;\n                        for (var j = 0; j < arr.length; j++) {\n                            var child = arr[j], simple = !(falsey(child) || isFunction(child) || child instanceof VNode);\n                            if (simple && !isString(child)) child = String(child);\n                            if (simple && lastSimple) children[children.length - 1] += child; else if (!falsey(child)) {\n                                children.push(child);\n                                lastSimple = simple;\n                            }\n                        }\n                    } else ;\n                }\n            }\n        } else if (attributes && attributes.children) return h(nodeName, attributes, attributes.children);\n        if (attributes) {\n            if (attributes.children) delete attributes.children;\n            if (!isFunction(nodeName)) {\n                if ('className' in attributes) {\n                    attributes.class = attributes.className;\n                    delete attributes.className;\n                }\n                lastSimple = attributes.class;\n                if (lastSimple && !isString(lastSimple)) attributes.class = hashToClassName(lastSimple);\n            }\n        }\n        var p = new VNode(nodeName, attributes || void 0, children);\n        if (options.vnode) options.vnode(p);\n        return p;\n    }\n    function cloneElement(vnode, props) {\n        return h(vnode.nodeName, extend(clone(vnode.attributes), props), arguments.length > 2 ? toArray(arguments, 2) : vnode.children);\n    }\n    function createLinkedState(component, key, eventPath) {\n        var path = key.split('.'), p0 = path[0];\n        return function(e) {\n            var _component$setState;\n            var v, i, t = e && e.currentTarget || this, s = component.state, obj = s;\n            if (isString(eventPath)) {\n                v = delve(e, eventPath);\n                if (empty(v) && (t = t._component)) v = delve(t, eventPath);\n            } else v = t.nodeName ? (t.nodeName + t.type).match(/^input(check|rad)/i) ? t.checked : t.value : e;\n            if (isFunction(v)) v = v.call(t);\n            if (path.length > 1) {\n                for (i = 0; i < path.length - 1; i++) obj = obj[path[i]] || (obj[path[i]] = {});\n                obj[path[i]] = v;\n                v = s[p0];\n            }\n            component.setState((_component$setState = {}, _component$setState[p0] = v, _component$setState));\n        };\n    }\n    function enqueueRender(component) {\n        if (1 === items.push(component)) (options.debounceRendering || defer)(rerender);\n    }\n    function rerender() {\n        if (items.length) {\n            var p, currentItems = items;\n            items = itemsOffline;\n            itemsOffline = currentItems;\n            while (p = currentItems.pop()) if (p._dirty) renderComponent(p);\n        }\n    }\n    function isFunctionalComponent(vnode) {\n        var nodeName = vnode && vnode.nodeName;\n        return nodeName && isFunction(nodeName) && !(nodeName.prototype && nodeName.prototype.render);\n    }\n    function buildFunctionalComponent(vnode, context) {\n        return vnode.nodeName(getNodeProps(vnode), context || EMPTY);\n    }\n    function ensureNodeData(node, data) {\n        return node[ATTR_KEY] || (node[ATTR_KEY] = data || {});\n    }\n    function getNodeType(node) {\n        if (node instanceof Text) return 3;\n        if (node instanceof Element) return 1; else return 0;\n    }\n    function removeNode(node) {\n        var p = node.parentNode;\n        if (p) p.removeChild(node);\n    }\n    function setAccessor(node, name, value, old, isSvg) {\n        ensureNodeData(node)[name] = value;\n        if ('key' !== name && 'children' !== name && 'innerHTML' !== name) if ('class' === name && !isSvg) node.className = value || ''; else if ('style' === name) {\n            if (!value || isString(value) || isString(old)) node.style.cssText = value || '';\n            if (value && 'object' == typeof value) {\n                if (!isString(old)) for (var i in old) if (!(i in value)) node.style[i] = '';\n                for (var i in value) node.style[i] = 'number' == typeof value[i] && !NON_DIMENSION_PROPS[i] ? value[i] + 'px' : value[i];\n            }\n        } else if ('dangerouslySetInnerHTML' === name) {\n            if (value) node.innerHTML = value.__html;\n        } else if (name.match(/^on/i)) {\n            var l = node._listeners || (node._listeners = {});\n            name = toLowerCase(name.substring(2));\n            if (value) {\n                if (!l[name]) node.addEventListener(name, eventProxy);\n            } else if (l[name]) node.removeEventListener(name, eventProxy);\n            l[name] = value;\n        } else if ('type' !== name && !isSvg && name in node) {\n            setProperty(node, name, empty(value) ? '' : value);\n            if (falsey(value)) node.removeAttribute(name);\n        } else {\n            var ns = isSvg && name.match(/^xlink\\:?(.+)/);\n            if (falsey(value)) if (ns) node.removeAttributeNS('http://www.w3.org/1999/xlink', toLowerCase(ns[1])); else node.removeAttribute(name); else if ('object' != typeof value && !isFunction(value)) if (ns) node.setAttributeNS('http://www.w3.org/1999/xlink', toLowerCase(ns[1]), value); else node.setAttribute(name, value);\n        }\n    }\n    function setProperty(node, name, value) {\n        try {\n            node[name] = value;\n        } catch (e) {}\n    }\n    function eventProxy(e) {\n        return this._listeners[e.type](options.event && options.event(e) || e);\n    }\n    function getRawNodeAttributes(node) {\n        var attrs = {};\n        for (var i = node.attributes.length; i--; ) attrs[node.attributes[i].name] = node.attributes[i].value;\n        return attrs;\n    }\n    function isSameNodeType(node, vnode) {\n        if (isString(vnode)) return 3 === getNodeType(node);\n        if (isString(vnode.nodeName)) return isNamedNode(node, vnode.nodeName);\n        if (isFunction(vnode.nodeName)) return node._componentConstructor === vnode.nodeName || isFunctionalComponent(vnode); else ;\n    }\n    function isNamedNode(node, nodeName) {\n        return node.normalizedNodeName === nodeName || toLowerCase(node.nodeName) === toLowerCase(nodeName);\n    }\n    function getNodeProps(vnode) {\n        var defaultProps = vnode.nodeName.defaultProps, props = clone(defaultProps || vnode.attributes);\n        if (defaultProps) extend(props, vnode.attributes);\n        if (vnode.children) props.children = vnode.children;\n        return props;\n    }\n    function collectNode(node) {\n        cleanNode(node);\n        var name = toLowerCase(node.nodeName), list = nodes[name];\n        if (list) list.push(node); else nodes[name] = [ node ];\n    }\n    function createNode(nodeName, isSvg) {\n        var name = toLowerCase(nodeName), node = nodes[name] && nodes[name].pop() || (isSvg ? document.createElementNS('http://www.w3.org/2000/svg', nodeName) : document.createElement(nodeName));\n        ensureNodeData(node);\n        node.normalizedNodeName = name;\n        return node;\n    }\n    function cleanNode(node) {\n        removeNode(node);\n        if (1 === getNodeType(node)) {\n            ensureNodeData(node, getRawNodeAttributes(node));\n            node._component = node._componentConstructor = null;\n        }\n    }\n    function flushMounts() {\n        var c;\n        while (c = mounts.pop()) if (c.componentDidMount) c.componentDidMount();\n    }\n    function diff(dom, vnode, context, mountAll, parent, rootComponent, nextSibling) {\n        diffLevel++;\n        var ret = idiff(dom, vnode, context, mountAll, rootComponent);\n        if (parent && ret.parentNode !== parent) parent.insertBefore(ret, nextSibling || null);\n        if (!--diffLevel) flushMounts();\n        return ret;\n    }\n    function idiff(dom, vnode, context, mountAll, rootComponent) {\n        var originalAttributes = vnode && vnode.attributes;\n        while (isFunctionalComponent(vnode)) vnode = buildFunctionalComponent(vnode, context);\n        if (empty(vnode)) {\n            vnode = '';\n            if (rootComponent) {\n                if (dom) {\n                    if (8 === dom.nodeType) return dom;\n                    collectNode(dom);\n                }\n                return document.createComment(vnode);\n            }\n        }\n        if (isString(vnode)) {\n            if (dom) {\n                if (3 === getNodeType(dom) && dom.parentNode) {\n                    dom.nodeValue = vnode;\n                    return dom;\n                }\n                collectNode(dom);\n            }\n            return document.createTextNode(vnode);\n        }\n        var svgMode, out = dom, nodeName = vnode.nodeName;\n        if (isFunction(nodeName)) return buildComponentFromVNode(dom, vnode, context, mountAll);\n        if (!isString(nodeName)) nodeName = String(nodeName);\n        svgMode = 'svg' === toLowerCase(nodeName);\n        if (svgMode) isSvgMode = !0;\n        if (!dom) out = createNode(nodeName, isSvgMode); else if (!isNamedNode(dom, nodeName)) {\n            out = createNode(nodeName, isSvgMode);\n            while (dom.firstChild) out.appendChild(dom.firstChild);\n            recollectNodeTree(dom);\n        }\n        if (vnode.children && 1 === vnode.children.length && 'string' == typeof vnode.children[0] && 1 === out.childNodes.length && out.firstChild instanceof Text) out.firstChild.nodeValue = vnode.children[0]; else if (vnode.children || out.firstChild) innerDiffNode(out, vnode.children, context, mountAll);\n        diffAttributes(out, vnode.attributes);\n        if (originalAttributes && originalAttributes.ref) (out[ATTR_KEY].ref = originalAttributes.ref)(out);\n        if (svgMode) isSvgMode = !1;\n        return out;\n    }\n    function innerDiffNode(dom, vchildren, context, mountAll) {\n        var j, c, vchild, child, originalChildren = dom.childNodes, children = [], keyed = {}, keyedLen = 0, min = 0, len = originalChildren.length, childrenLen = 0, vlen = vchildren && vchildren.length;\n        if (len) for (var i = 0; i < len; i++) {\n            var _child = originalChildren[i], key = vlen ? (c = _child._component) ? c.__key : (c = _child[ATTR_KEY]) ? c.key : null : null;\n            if (key || 0 === key) {\n                keyedLen++;\n                keyed[key] = _child;\n            } else children[childrenLen++] = _child;\n        }\n        if (vlen) for (var i = 0; i < vlen; i++) {\n            vchild = vchildren[i];\n            child = null;\n            if (keyedLen && vchild.attributes) {\n                var key = vchild.key;\n                if (!empty(key) && key in keyed) {\n                    child = keyed[key];\n                    keyed[key] = void 0;\n                    keyedLen--;\n                }\n            }\n            if (!child && min < childrenLen) for (j = min; j < childrenLen; j++) {\n                c = children[j];\n                if (c && isSameNodeType(c, vchild)) {\n                    child = c;\n                    children[j] = void 0;\n                    if (j === childrenLen - 1) childrenLen--;\n                    if (j === min) min++;\n                    break;\n                }\n            }\n            child = idiff(child, vchild, context, mountAll);\n            if (child !== originalChildren[i]) dom.insertBefore(child, originalChildren[i] || null);\n        }\n        if (keyedLen) for (var i in keyed) if (keyed[i]) children[min = childrenLen++] = keyed[i];\n        if (min < childrenLen) removeOrphanedChildren(children);\n    }\n    function removeOrphanedChildren(children, unmountOnly) {\n        for (var i = children.length; i--; ) {\n            var child = children[i];\n            if (child) recollectNodeTree(child, unmountOnly);\n        }\n    }\n    function recollectNodeTree(node, unmountOnly) {\n        var component = node._component;\n        if (component) unmountComponent(component, !unmountOnly); else {\n            if (node[ATTR_KEY] && node[ATTR_KEY].ref) node[ATTR_KEY].ref(null);\n            if (!unmountOnly) collectNode(node);\n            if (node.childNodes && node.childNodes.length) removeOrphanedChildren(node.childNodes, unmountOnly);\n        }\n    }\n    function diffAttributes(dom, attrs) {\n        var old = dom[ATTR_KEY] || getRawNodeAttributes(dom);\n        for (var _name in old) if (!(attrs && _name in attrs)) setAccessor(dom, _name, null, old[_name], isSvgMode);\n        if (attrs) for (var _name2 in attrs) if (!(_name2 in old) || attrs[_name2] != old[_name2] || ('value' === _name2 || 'checked' === _name2) && attrs[_name2] != dom[_name2]) setAccessor(dom, _name2, attrs[_name2], old[_name2], isSvgMode);\n    }\n    function collectComponent(component) {\n        var name = component.constructor.name, list = components[name];\n        if (list) list.push(component); else components[name] = [ component ];\n    }\n    function createComponent(Ctor, props, context) {\n        var inst = new Ctor(props, context), list = components[Ctor.name];\n        inst.props = props;\n        inst.context = context;\n        if (list) for (var i = list.length; i--; ) if (list[i].constructor === Ctor) {\n            inst.nextBase = list[i].nextBase;\n            list.splice(i, 1);\n            break;\n        }\n        return inst;\n    }\n    function triggerComponentRender(component) {\n        if (!component._dirty) {\n            component._dirty = !0;\n            enqueueRender(component);\n        }\n    }\n    function setComponentProps(component, props, opts, context, mountAll) {\n        var b = component.base;\n        if (!component._disableRendering) {\n            component._disableRendering = !0;\n            if (component.__ref = props.ref) delete props.ref;\n            if (component.__key = props.key) delete props.key;\n            if (empty(b) || mountAll) {\n                if (component.componentWillMount) component.componentWillMount();\n            } else if (component.componentWillReceiveProps) component.componentWillReceiveProps(props, context);\n            if (context && context !== component.context) {\n                if (!component.prevContext) component.prevContext = component.context;\n                component.context = context;\n            }\n            if (!component.prevProps) component.prevProps = component.props;\n            component.props = props;\n            component._disableRendering = !1;\n            if (0 !== opts) if (1 === opts || options.syncComponentUpdates !== !1 || !b) renderComponent(component, 1, mountAll); else triggerComponentRender(component);\n            if (component.__ref) component.__ref(component);\n        }\n    }\n    function renderComponent(component, opts, mountAll) {\n        if (!component._disableRendering) {\n            var skip, rendered, props = component.props, state = component.state, context = component.context, previousProps = component.prevProps || props, previousState = component.prevState || state, previousContext = component.prevContext || context, isUpdate = component.base, initialBase = isUpdate || component.nextBase, baseParent = initialBase && initialBase.parentNode, initialComponent = initialBase && initialBase._component, initialChildComponent = component._component;\n            if (isUpdate) {\n                component.props = previousProps;\n                component.state = previousState;\n                component.context = previousContext;\n                if (2 !== opts && component.shouldComponentUpdate && component.shouldComponentUpdate(props, state, context) === !1) skip = !0; else if (component.componentWillUpdate) component.componentWillUpdate(props, state, context);\n                component.props = props;\n                component.state = state;\n                component.context = context;\n            }\n            component.prevProps = component.prevState = component.prevContext = component.nextBase = null;\n            component._dirty = !1;\n            if (!skip) {\n                if (component.render) rendered = component.render(props, state, context);\n                if (component.getChildContext) context = extend(clone(context), component.getChildContext());\n                while (isFunctionalComponent(rendered)) rendered = buildFunctionalComponent(rendered, context);\n                var toUnmount, base, childComponent = rendered && rendered.nodeName;\n                if (isFunction(childComponent) && childComponent.prototype.render) {\n                    var inst = initialChildComponent, childProps = getNodeProps(rendered);\n                    if (inst && inst.constructor === childComponent) setComponentProps(inst, childProps, 1, context); else {\n                        toUnmount = inst;\n                        inst = createComponent(childComponent, childProps, context);\n                        inst._parentComponent = component;\n                        component._component = inst;\n                        setComponentProps(inst, childProps, 0, context);\n                        renderComponent(inst, 1);\n                    }\n                    base = inst.base;\n                } else {\n                    var cbase = initialBase;\n                    toUnmount = initialChildComponent;\n                    if (toUnmount) cbase = component._component = null;\n                    if (initialBase || 1 === opts) {\n                        if (cbase) cbase._component = null;\n                        base = diff(cbase, rendered, context, mountAll || !isUpdate, baseParent, !0, initialBase && initialBase.nextSibling);\n                    }\n                }\n                if (initialBase && base !== initialBase) if (!toUnmount && initialComponent === component && !initialChildComponent && initialBase.parentNode) {\n                    initialBase._component = null;\n                    recollectNodeTree(initialBase);\n                }\n                if (toUnmount) unmountComponent(toUnmount, !0);\n                component.base = base;\n                if (base) {\n                    var componentRef = component, t = component;\n                    while (t = t._parentComponent) componentRef = t;\n                    base._component = componentRef;\n                    base._componentConstructor = componentRef.constructor;\n                }\n            }\n            if (!isUpdate || mountAll) {\n                mounts.unshift(component);\n                if (!diffLevel) flushMounts();\n            } else if (!skip && component.componentDidUpdate) component.componentDidUpdate(previousProps, previousState, previousContext);\n            var fn, cb = component._renderCallbacks;\n            if (cb) while (fn = cb.pop()) fn.call(component);\n            return rendered;\n        }\n    }\n    function buildComponentFromVNode(dom, vnode, context, mountAll) {\n        var c = dom && dom._component, oldDom = dom, isDirectOwner = c && dom._componentConstructor === vnode.nodeName, isOwner = isDirectOwner, props = getNodeProps(vnode);\n        while (c && !isOwner && (c = c._parentComponent)) isOwner = c.constructor === vnode.nodeName;\n        if (isOwner && (!mountAll || c._component)) {\n            setComponentProps(c, props, 3, context, mountAll);\n            dom = c.base;\n        } else {\n            if (c && !isDirectOwner) {\n                unmountComponent(c, !0);\n                dom = oldDom = null;\n            }\n            c = createComponent(vnode.nodeName, props, context);\n            if (dom && !c.nextBase) c.nextBase = dom;\n            setComponentProps(c, props, 1, context, mountAll);\n            dom = c.base;\n            if (oldDom && dom !== oldDom) {\n                oldDom._component = null;\n                recollectNodeTree(oldDom);\n            }\n        }\n        return dom;\n    }\n    function unmountComponent(component, remove) {\n        var base = component.base;\n        component._disableRendering = !0;\n        if (component.componentWillUnmount) component.componentWillUnmount();\n        component.base = null;\n        var inner = component._component;\n        if (inner) unmountComponent(inner, remove); else if (base) {\n            if (base[ATTR_KEY] && base[ATTR_KEY].ref) base[ATTR_KEY].ref(null);\n            component.nextBase = base;\n            if (remove) {\n                removeNode(base);\n                collectComponent(component);\n            }\n            removeOrphanedChildren(base.childNodes, !remove);\n        }\n        if (component.__ref) component.__ref(null);\n        if (component.componentDidUnmount) component.componentDidUnmount();\n    }\n    function Component(props, context) {\n        this._dirty = !0;\n        this._disableRendering = !1;\n        this.prevState = this.prevProps = this.prevContext = this.base = this.nextBase = this._parentComponent = this._component = this.__ref = this.__key = this._linkedStates = this._renderCallbacks = null;\n        this.context = context;\n        this.props = props;\n        this.state = this.getInitialState && this.getInitialState() || {};\n    }\n    function render(vnode, parent, merge) {\n        return diff(merge, vnode, {}, !1, parent);\n    }\n    var lcCache = {};\n    var toLowerCase = function(s) {\n        return lcCache[s] || (lcCache[s] = s.toLowerCase());\n    };\n    var resolved = 'undefined' != typeof Promise && Promise.resolve();\n    var defer = resolved ? function(f) {\n        resolved.then(f);\n    } : setTimeout;\n    var options = {\n        vnode: empty\n    };\n    var SHARED_TEMP_ARRAY = [];\n    var EMPTY = {};\n    var ATTR_KEY = 'undefined' != typeof Symbol ? Symbol.for('preactattr') : '__preactattr_';\n    var NON_DIMENSION_PROPS = {\n        boxFlex: 1,\n        boxFlexGroup: 1,\n        columnCount: 1,\n        fillOpacity: 1,\n        flex: 1,\n        flexGrow: 1,\n        flexPositive: 1,\n        flexShrink: 1,\n        flexNegative: 1,\n        fontWeight: 1,\n        lineClamp: 1,\n        lineHeight: 1,\n        opacity: 1,\n        order: 1,\n        orphans: 1,\n        strokeOpacity: 1,\n        widows: 1,\n        zIndex: 1,\n        zoom: 1\n    };\n    var items = [];\n    var itemsOffline = [];\n    var nodes = {};\n    var mounts = [];\n    var diffLevel = 0;\n    var isSvgMode = !1;\n    var components = {};\n    extend(Component.prototype, {\n        linkState: function(key, eventPath) {\n            var c = this._linkedStates || (this._linkedStates = {}), cacheKey = key + '|' + eventPath;\n            return c[cacheKey] || (c[cacheKey] = createLinkedState(this, key, eventPath));\n        },\n        setState: function(state, callback) {\n            var s = this.state;\n            if (!this.prevState) this.prevState = clone(s);\n            extend(s, isFunction(state) ? state(s, this.props) : state);\n            if (callback) (this._renderCallbacks = this._renderCallbacks || []).push(callback);\n            triggerComponentRender(this);\n        },\n        forceUpdate: function() {\n            renderComponent(this, 2);\n        },\n        render: function() {\n            return null;\n        }\n    });\n    exports.h = h;\n    exports.cloneElement = cloneElement;\n    exports.Component = Component;\n    exports.render = render;\n    exports.rerender = rerender;\n    exports.options = options;\n});\n//# sourceMappingURL=preact.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/preact/dist/preact.js\n// module id = 1\n// module chunks = 0 1","import { h, Component } from 'preact';\r\nimport ChatFrame from './ChatFrame';\r\n\r\nconst wrapperStyle = {\r\n    position: 'fixed',\r\n    bottom: '0px',\r\n    right: '4px',\r\n    zIndex: 2147483647,\r\n    borderRadius: '5px',\r\n    border: '1px solid rgba(82,179,217,0.9)',\r\n    width: '300px',\r\n};\r\n\r\nconst titleStyle = {\r\n    height: '30px',\r\n    lineHeight: '30px',\r\n    fontSize: '20px',\r\n    paddingLeft: '10px',\r\n    fontFamily: 'Lato, sans-serif',\r\n    background: 'rgba(82,179,217,0.9)',\r\n    color: '#fff',\r\n    cursor: 'pointer'\r\n};\r\n\r\n\r\nexport default class App extends Component {\r\n\r\n    state = {\r\n        pristine: true,\r\n        isChatOpen: false\r\n    };\r\n\r\n    render({},{}) {\r\n        return (\r\n            <div style={wrapperStyle}>\r\n\r\n                {/*Title*/}\r\n                <div style={titleStyle} onClick={this.onClick}>\r\n                    {!this.state.isChatOpen ? \"Click to chat with us!\" : \"Intergram\"}\r\n                </div>\r\n\r\n                {/*Chat IFrame*/}\r\n                <div style={{display: this.state.isChatOpen ? 'block' : 'none'}}>\r\n                    {this.state.pristine ? null : <ChatFrame /> }\r\n                </div>\r\n\r\n            </div>\r\n        );\r\n    }\r\n\r\n    onClick = () => {\r\n        if (!window.intergramId) {\r\n            console.error(\"To use Intergram you have to set an intergramId \");\r\n            return;\r\n        }\r\n\r\n        this.setState({\r\n            pristine: false,\r\n            isChatOpen: !this.state.isChatOpen\r\n        });\r\n\r\n    };\r\n\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/widget/App.js","import { h, Component } from 'preact';\r\n\r\nexport default class ChatFrame extends Component {\r\n\r\n    shouldComponentUpdate() {\r\n        // do not re-render via diff:\r\n        return false;\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            // Using a static link to GitHub pages - this might be confusing during development!\r\n            <iframe src={'https://idoco.github.io/intergram/chat.html?id=' + window.intergramId }\r\n                    width='300' height='350' frameborder='0'>\r\n            </iframe>\r\n        );\r\n    }\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/widget/ChatFrame.js","import { h, render } from 'preact';\r\nimport App from './App';\r\n\r\nif (window.attachEvent) {\r\n    window.attachEvent('onload', injectChat);\r\n} else {\r\n    window.addEventListener('load', injectChat, false);\r\n}\r\n\r\nfunction injectChat() {\r\n    let root = document.createElement('div');\r\n    root.id = 'intergramRoot';\r\n    document.getElementsByTagName('body')[0].appendChild(root);\r\n    render(<App />, root);\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/widget/widgetIndex.js"],"sourceRoot":""}